from pydantic import BaseModel, conint, validator
from decimal import Decimal
from typing import List

# DC projection input
class DCProjectionInput(BaseModel):
    current_balance: Decimal
    annual_salary: Decimal
    contribution_rate: Decimal  # decimal (0.08 == 8%)
    salary_growth: Decimal  # decimal per year
    rate_of_return: Decimal  # decimal per year
    years: conint(ge=0)  # integer years
    accrual_frequency: conint(ge=1) = 1  # times per year (default 1)

    @validator("contribution_rate", "salary_growth", "rate_of_return", pre=True)
    def to_decimal(cls, v):
        return Decimal(str(v))

    @validator("contribution_rate")
    def check_contribution(cls, v):
        if v < 0 or v > 1:
            raise ValueError("contribution_rate must be between 0 and 1 (decimal)")
        return v

class YearBalance(BaseModel):
    year: int
    salary: Decimal
    contribution: Decimal
    balance: Decimal

class DCProjectionOutput(BaseModel):
    initial_balance: Decimal
    annual_balances: List[YearBalance]
    final_balance: Decimal

# DB accrual
class DBAccrualInput(BaseModel):
    final_salary: Decimal
    years_of_service: conint(ge=0)
    accrual_rate: Decimal  # e.g., 0.02 -> 2% per year

    @validator("accrual_rate", pre=True)
    def to_decimal(cls, v):
        return Decimal(str(v))

class DBAccrualOutput(BaseModel):
    annual_accrual: Decimal
    total_pension: Decimal

# Annuity conversion
class AnnuityInput(BaseModel):
    lump_sum: Decimal
    rate_of_return: Decimal
    payment_periods: conint(ge=1)
    payment_frequency_per_year: conint(ge=1) = 12

    @validator("rate_of_return", pre=True)
    def to_decimal(cls, v):
        return Decimal(str(v))

class AnnuityOutput(BaseModel):
    periodic_payment: Decimal
    annuity_factor: Decimal
